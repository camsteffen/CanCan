<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Cancan by wpm</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Cancan</h1>
        <p>A solver and generator of KenKen puzzles</p>

        <p class="view"><a href="https://github.com/wpm/CanCan">View the Project on GitHub <small>wpm/CanCan</small></a></p>


        <ul>
          <li><a href="https://github.com/wpm/CanCan/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/wpm/CanCan/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/wpm/CanCan">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>CanCan is a program that generates and solves KenKen puzzles.</p>

<p><a href="http://www.kenken.com">KenKen</a> is a math puzzle in which the objective is to fill in every cell in a square <em>n</em> x <em>n</em> grid with a number.
The numbers in all the rows and columns must be unique.
(So a solved KenKen puzzle is a <a href="http://en.wikipedia.org/wiki/Latin_square">Latin Square</a>.)
Additionally contiguous cells are grouped into blocks called cages, and the sum, product, quotient or difference of the numbers in each cage must equal a target value.
Here is a typical puzzle with its solution.</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/KenKenSolution.svg/250px-KenKenSolution.svg.png" alt="A solved KenKen puzzle"></p>

<p>KenKen can be approached as a problem in constraint satisfaction.
Adopting the nomenclature used in (<a href="#crook2009">Crook 2009</a>), a <em>markup</em> is an assignment of sets of numbers from 1 to n to each cell.
The set of possible markups defines the search space.
This space may be visualized as a graph where a directed edge points from one markup to another with a single value assigned to one of the cells.
The subgraph for a given permutation of cells defines a tree.
Since there are <em>n</em><sup>2</sup>(2<sup><em>n</em></sup>-1) possible markups and <em>n</em><sup>3</sup> possible solutions, an exhaustive search of the space is intractable.
However, after we cross each edge in the graph (including an initial null edge that leads to the start state) we can apply all the constraints, which eliminates values from the markups.
The algorithm to find a solution is therefore a depth-first search of a markup tree with constraint propagation at each step.</p>

<p>KenKen generation primarily an exercise in tiling the square with cages. An algorithm that does this is as follows.</p>

<ol>
<li>Generate a random Latin Square as the solution of the puzzle.</li>
<li>Make an undirected graph whose vertices are cells and whose edges are randomly assigned between adjacent cells.</li>
<li>Partition this graph into its connected components, limiting each component to a randomly chosen maximum size. These are the cages.</li>
<li>To each cage randomly assign an arithmetic operator (+, -, รท, ร) and calculate the corresponding target value. For 1-cell cages, the target value is just the value in the cell.</li>
</ol><p>You need a distribution over cage sizes from which to sample in step (2).
Its exact values are manually adjusted to produce a range of cage sizes that makes for interesting puzzles.
Note that as a grid gets filled in, larger cages will not fit inside the remaining space, so the resulting empirical distribution of cage sizes will skew smaller than the one used for sampling.
It is also easy to end up with puzzles containing a large number of single-cell cages.
These tend to be too easy to solve, so it helps to filter out generated puzzles with a proportion of single-cell cages above some maximum.
Finally there is no guarantee that a given set of cage constraints will have a unique solution.
In order to guarantee uniqueness each puzzle generated in step (4) must then be solved and ones with more than one solution discarded.</p>

<p>KenKen can be thought of as a generalization of Sudoku puzzles.
Peter Norvig has a <a href="http://norvig.com/sudoku.html">Sudoku solver</a> which uses the same constraint propagation algorithm.
Michael Heyeck has written a KenKen solver in Python called <a href="http://www.mlsite.net/neknek">neknek</a>.
CanCan can write puzzles in the format recognized by neknek.</p>

<p>Here is a set of over <a href="https://docs.google.com/folder/d/0B1KTYK5LG8lXendkT3R0VERxQXM/edit">40,000 KenKen puzzles</a> of sizes ranging from 4x4 to 9x9 with unique solutions.</p>

<h1>References</h1>

<p><a href="http://www.ams.org/notices/200904/tx090400460p.pdf">J.F. Crook, "A pencil-and-paper algorithm for solving Sudoku puzzles", <em>Notices of the American Mathematical Society</em>, April 2009, Volume 56, Number 4, pp. 460-468</a></p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/wpm">wpm</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>